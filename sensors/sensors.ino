#include "Settings.h"
#include <Arduino.h>
#include <Timer.h>
#include <MemoryFree.h>
#include <ros.h>
#include <std_msgs/Empty.h>
#include "Device.h"
#include "RosSettings.h"

// Restart Macro
#define CPU_RESTART_ADDR (uint32_t *)0xE000ED0C
#define CPU_RESTART_VAL 0x5FA0004
#define CPU_RESTART (*CPU_RESTART_ADDR = CPU_RESTART_VAL);

void KickDog();

// check the headers in Settings.h and include different devices

#if(ROS_ENABLED)
  ros::NodeHandle nh;
#endif

#if(HAS_OS5000)
  #include "os5000.h"
  OS5000 IMUSensor;

  // imu serial pass
  void serialConnectCb( const std_msgs::Empty &msg ) {
    IMUSensor.serialConnect();
  }
  ros::Subscriber<std_msgs::Empty> serialSub("sensors/serialIMU", &serialConnectCb);

  /*
   * Serial event generated by OS5000
   */
  void serialEvent1() {
    IMUSensor.read_serial();
  }
#endif

#if(HAS_MS5803)
  #include "MS5803_14BA.h"
  #include <i2c_t3.h>
  #include <EEPROM.h>
  MS5803_14BA DepthSensor;
  // depth calibration
  void calibrateCb( const std_msgs::Empty &msg ) {
    DepthSensor.calibrate();
  }
  ros::Subscriber<std_msgs::Empty> caliSub("sensors/calibrateDepth", &calibrateCb);
#endif

#if(HAS_TOUCH)
  #include <ADC.h>
  #include "Touch.h"
  Touch TouchSensor;
  void adc0_isr(void) {
    TouchSensor.readADC();
  }
#endif

IntervalTimer wdTimer;
IntervalTimer ledTimer;
Timer Output5000ms;   // 1Hz
Timer Output25ms;     // 40Hz
int loops_per_sec;

void setup() {
  // turn on starup led
  pinMode( LED_BUILTIN, OUTPUT );
  digitalWrite( LED_BUILTIN, HIGH );

  // setup timers
  wdTimer.begin(KickDog, 500000);
  ledTimer.begin(DeviceManager::doLedStatus, 500000);

  #if(ROS_ENABLED)
    DeviceManager::doRosInits();
    nh.initNode();          // initialize ros node
    #if(HAS_MS5803) 
      nh.subscribe( caliSub ); 
    #endif
    #if(HAS_OS5000)
      nh.subscribe( serialSub );
    #endif
    while(!nh.connected()) nh.spinOnce();
  #else
    Serial.begin(115200);   // initialize serial comm
    while(!Serial);
  #endif

  // Start up reason
  if (RCM_SRS0 & RCM_SRS0_POR)
    LOG_INFO( "sensors: reset - power-on reset;" );
  if (RCM_SRS0 & RCM_SRS0_PIN)
    LOG_INFO( "sensors: reset - external-pin reset;" );
  if (RCM_SRS0 & RCM_SRS0_WDOG)
    LOG_INFO( "resets: watchdog reset;" );

  Output5000ms.reset();
  Output25ms.reset();

  DeviceManager::doDeviceSetups();

  // Boot message
  LOG_INFO( "sensors: boot=success;" );
  LOG_INFO( "-------------------------------------------" );
  wdTimer.end();
}

int blink = LOW;

void loop() {
  DeviceManager::doDeviceLoops();
  loops_per_sec++;

  // 1Hz Cycle
  if(Output5000ms.elapsed(5000)) {
    #if(ROS_ENABLED)
      char stats[30]; sprintf( stats,
            "sensors: alps=%d; free ram=%d;",
            loops_per_sec/5, freeMemory() );
      LOG_DEBUG(stats);
    #else
      Serial.print(F("alps:"));
      Serial.print(loops_per_sec);
      Serial.println(';');

      Serial.print(F("free ram:"));
      Serial.print(freeMemory(), DEC);
      Serial.println(";");
    #endif

    loops_per_sec = 0;

  }

  // 40Hz Cycle
  if(Output25ms.elapsed(25)) {
    KickDog();
    // blink led
    digitalWrite(LED_BUILTIN, blink); blink = !blink;
  }

  // Restart on connection loss
  #if(ROS_ENABLED)
    if(!nh.connected()) CPU_RESTART;
  #else
    if(!Serial) CPU_RESTART;
  #endif

  #if(ROS_ENABLED)
    nh.spinOnce();
  #endif
}

/*
 * Sets up watchdog timer
 * Watchdog clock without prescalar = 1KHz
 * Watchdog reset time = WDOG_TOVALL / WDOG_CLK
 * Current value = 1Hz (1000/1000)
 */

#ifdef __cplusplus
extern "C" {
#endif

void startup_early_hook() {
  WDOG_TOVALL = 1000;     // value that the watchdog timer compares itself to
  WDOG_TOVALH = 0;
  // Enable watchdog
  WDOG_STCTRLH = (WDOG_STCTRLH_ALLOWUPDATE | WDOG_STCTRLH_WDOGEN |
    WDOG_STCTRLH_WAITEN | WDOG_STCTRLH_STOPEN );
  WDOG_PRESC = 0;           // 1Khz
}

#ifdef __cplusplus
}
#endif

/*
 * Restarts the watchdog timer
 */
void KickDog() {
  noInterrupts();
  WDOG_REFRESH = 0xA602;
  WDOG_REFRESH = 0xB480;
  interrupts();
}
